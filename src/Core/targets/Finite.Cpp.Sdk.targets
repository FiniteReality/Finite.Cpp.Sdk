<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup Condition="'$(OutputType)' == 'library'">
    <LibraryType Condition="'$(LibraryType)' == ''">shared</LibraryType>
  </PropertyGroup>

  <!--
    Since we're overriding Microsoft.Common.CurrentVersion.targets, we have to
    check that the user didn't intentionally override them beforehand somehow.
    $(_OverridenTargetExt) will be true if TargetExt was set *before* importing
    Microsoft.Common.CurrentVersion.targets
  -->
  <PropertyGroup Condition="'$(_OverridenTargetExt)' != 'true' and '$(OS)' == 'Windows_NT'">
    <TargetExt Condition="'$(OutputType)' == 'exe'">.exe</TargetExt>
    <TargetExt Condition="'$(OutputType)' == 'library' and '$(LibraryType)' == 'shared'">.dll</TargetExt>
    <TargetExt Condition="'$(OutputType)' == 'library' and '$(LibraryType)' == 'static'">.lib</TargetExt>
  </PropertyGroup>

  <PropertyGroup Condition="'$(_OverridenTargetExt)' != 'true' and '$(OS)' == 'OSX'">
    <TargetExt Condition="'$(OutputType)' == 'exe'"></TargetExt>
    <TargetExt Condition="'$(OutputType)' == 'library' and '$(LibraryType)' == 'shared'">.dylib</TargetExt>
    <TargetExt Condition="'$(OutputType)' == 'library' and '$(LibraryType)' == 'static'">.a</TargetExt>
  </PropertyGroup>

  <PropertyGroup Condition="'$(_OverridenTargetExt)' != 'true' and '$(OS)' == 'Unix'">
    <TargetExt Condition="'$(OutputType)' == 'exe'"></TargetExt>
    <TargetExt Condition="'$(OutputType)' == 'library' and '$(LibraryType)' == 'shared'">.so</TargetExt>
    <TargetExt Condition="'$(OutputType)' == 'library' and '$(LibraryType)' == 'static'">.a</TargetExt>
  </PropertyGroup>

  <!--
    Update properties which would otherwise be set by
    Microsoft.Common.CurrentVersion.targets based on the target extension.
    If the user has overridden the target extension somehow, we bail out and
    assume they've updated TargetFileName/TargetPath as appropriate.
  -->
  <PropertyGroup Condition="'$(_OverridenTargetExt)' != 'true'">
    <TargetFileName>$(TargetName)$(TargetExt)</TargetFileName>
    <TargetPath>$(TargetDir)$(TargetFileName)</TargetPath>
  </PropertyGroup>

  <PropertyGroup>
    <!-- C/C++ projects cannot produce .NET reference assemblies -->
    <ProduceReferenceAssembly>false</ProduceReferenceAssembly>
  </PropertyGroup>

  <Import Project="$(MSBuildThisFileDirectory)Finite.Cpp.Sdk.DefaultItems.targets" />

  <!-- Needed by Microsoft.Common.CurrentVersion.targets -->
  <Target Name="CreateManifestResourceNames" />

  <PropertyGroup>
    <CompileDependsOn>
      $(CompileDependsOn)
      BeforeLink;
      <!--_TimeStampBeforeLink;-->
      _GenerateLinkDependencyCache;
      CoreLink;
      <!--_TimeStampAfterLink;-->
      AfterLink;
    </CompileDependsOn>
  </PropertyGroup>

  <Target Name="CoreCompile"
    Inputs="$(MSBuildAllProjects);@(Compile);"
    Outputs="@(Link)">

    <ClangCompile
      EnableDebugSymbols="$(DebugSymbols)"
      IncludeDirectories="@(IncludeDirectories)"
      LibraryType="$(LibraryType)"
      Optimize="$(Optimize)"
      OptimizeLevel="$(OptimizeLevel)"
      OutputDirectory="$(IntermediateOutputPath)"
      OutputFileExtension="$(DefaultIntermediateExtension)"
      OutputType="$(OutputType)"
      SourceFile="%(Compile.FullPath)">
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </ClangCompile>
  </Target>

  <Target Name="CoreLink"
    DependsOnTargets="CoreCompile"
    Inputs="$(MSBuildAllProjects);@(Link)"
    Outputs="@(IntermediateAssembly)">

    <ClangLink
      EnableDebugSymbols="$(DebugSymbols)"
      LibraryType="$(LibraryType)"
      LinkLibraries="@(ReferencePath)"
      Optimize="$(Optimize)"
      OptimizeLevel="$(OptimizeLevel)"
      OutputDirectory="$(IntermediateOutputPath)"
      OutputFile="@(IntermediateAssembly)"
      OutputFileExtension="$(TargetExt)"
      OutputType="$(OutputType)"
      SourceFiles="@(Link)">
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </ClangLink>
  </Target>

  <Target Name="BeforeLink" />

  <Target Name="AfterLink" />

  <Target Name="_GenerateLinkDependencyCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences">
    <ItemGroup>
      <CustomAdditionalLinkInputs Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreLinkInputs.cache" />
      <CoreLinkCache Include="@(Link)" />
      <CoreLinkCache Include="@(ReferencePath)" />
      <CoreLinkCache Include="$(DefineConstants)" />
    </ItemGroup>

    <Hash
      ItemsToHash="@(CoreLinkCache)"
      IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CoreLinkCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CoreLinkDependencyHash" />
    </Hash>

    <WriteLinesToFile Lines="$(CoreLinkDependencyHash)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreLinkInputs.cache" Overwrite="True" WriteOnlyWhenDifferent="True" />

    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreLinkInputs.cache" />
    </ItemGroup>
  </Target>

  <ItemGroup>
    <ProjectCapability Remove="AssemblyReferences" />
    <ProjectCapability Remove="ReferenceManagerAssemblies" />
    <ProjectCapability Include="VisualC" Condition="'$(OS)' == 'Windows_NT'" />
    <ProjectCapability Include="CrossPlatformExecutable" />
    <ProjectCapability Include="ReferencesFolder" />
  </ItemGroup>

</Project>
